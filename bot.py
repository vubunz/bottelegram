import os
import logging
from datetime import datetime, timedelta, time
import requests
from bs4 import BeautifulSoup
from dotenv import load_dotenv
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Get bot token from environment variable
TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send a message when the command /start is issued."""
    await update.message.reply_text(
        'Xin ch√†o! T√¥i l√† bot XSMB. G·ª≠i /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng.'
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send help message."""
    help_message = """
üéØ H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG BOT X·ªî S·ªê MI·ªÄN B·∫ÆC üéØ

C√°c l·ªánh c√≥ s·∫µn:
/start    - Kh·ªüi ƒë·ªông bot
/help     - Xem h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
/ketqua   - Xem k·∫øt qu·∫£ x·ªï s·ªë ng√†y h√¥m nay
/ketqua_dd_mm - Xem k·∫øt qu·∫£ theo ng√†y
/xien2_xx_xx - Ki·ªÉm tra xien 2
    
C√°ch s·ª≠ d·ª•ng xem k·∫øt qu·∫£ theo ng√†y:
- C√∫ ph√°p: /ketqua_dd_mm
- Trong ƒë√≥: dd l√† ng√†y, mm l√† th√°ng
- V√≠ d·ª•: /ketqua_30_03 ƒë·ªÉ xem k·∫øt qu·∫£ ng√†y 30 th√°ng 3

‚ö†Ô∏è L∆∞u √Ω: 
- C√°c s·ªë ng√†y v√† th√°ng ph·∫£i l√† s·ªë h·ª£p l·ªá
- ƒê·ªãnh d·∫°ng ph·∫£i ch√≠nh x√°c nh∆∞ h∆∞·ªõng d·∫´n
"""
    await update.message.reply_text(help_message)

async def get_full_result(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fetch and display current day XSMB result."""
    try:
        url = "https://rongbachkim.net/ketqua.html"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        }
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        
        soup = BeautifulSoup(response.text, 'html.parser')
        table = soup.find('table', class_='ketqua')
        
        if table:
            # Parse and format result
            date_header = table.find('th', class_='kq_ngay').text.strip()
            message = format_result(table, date_header)
            await update.message.reply_text(message)
        else:
            await update.message.reply_text("Kh√¥ng th·ªÉ t√¨m th·∫•y k·∫øt qu·∫£ x·ªï s·ªë. Vui l√≤ng th·ª≠ l·∫°i sau.")
            
    except Exception as e:
        logging.error(f"Error fetching XSMB result: {e}")
        await update.message.reply_text("C√≥ l·ªói x·∫£y ra khi l·∫•y k·∫øt qu·∫£. Vui l√≤ng th·ª≠ l·∫°i sau.")

async def get_result_by_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fetch XSMB result for specific date."""
    try:
        command = update.message.text.strip().lower()
        
        if not command.startswith('/ketqua_'):
            await help_command(update, context)
            return

        try:
            date_part = command[8:]
            day, month = map(int, date_part.split('_'))
            
            if not (1 <= day <= 31 and 1 <= month <= 12):
                raise ValueError
                
        except (ValueError, IndexError):
            await help_command(update, context)
            return

        # Ki·ªÉm tra ng√†y y√™u c·∫ßu c√≥ trong ph·∫°m vi 2 ng√†y g·∫ßn nh·∫•t kh√¥ng
        current_date = datetime.now()
        requested_date = datetime(current_date.year, month, day)
        yesterday = current_date - timedelta(days=1)

        if requested_date.date() > current_date.date():
            await update.message.reply_text(
                "‚ùå Kh√¥ng th·ªÉ xem k·∫øt qu·∫£ c·ªßa ng√†y trong t∆∞∆°ng lai!\n"
                "Vui l√≤ng ch·ªçn ng√†y kh√°c."
            )
            return
        elif requested_date.date() < yesterday.date():
            await update.message.reply_text(
                f"‚ùå R·∫•t ti·∫øc, bot ch·ªâ c√≥ th·ªÉ xem k·∫øt qu·∫£ c·ªßa 2 ng√†y g·∫ßn nh·∫•t "
                f"({yesterday.strftime('%d/%m')} v√† {current_date.strftime('%d/%m')}).\n\n"
                f"ƒê·ªÉ xem k·∫øt qu·∫£ ng√†y {day:02d}/{month:02d}, "
                f"b·∫°n c√≥ th·ªÉ truy c·∫≠p:\n"
                f"- https://xoso.me/xsmb-{day:02d}-{month:02d}-{current_date.year}\n"
                f"- https://www.minhngoc.net.vn/xo-so-mien-bac/{day:02d}-{month:02d}-{current_date.year}.html"
            )
            return

        # Ti·∫øp t·ª•c code l·∫•y k·∫øt qu·∫£ nh∆∞ c≈© n·∫øu l√† 2 ng√†y g·∫ßn nh·∫•t
        processing_message = await update.message.reply_text("‚è≥ ƒêang l·∫•y k·∫øt qu·∫£...")

        current_year = datetime.now().year
        url = "https://rongbachkim.net/ketqua.html"
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        }
        
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # T√¨m table d·ª±a v√†o thu·ªôc t√≠nh rel ch·ª©a ng√†y th√°ng
        target_date = f"{current_year}-{month:02d}-{day:02d}"
        table = soup.find('table', attrs={'rel': target_date})
        
        await processing_message.delete()

        if table:
            date_header = table.find('th', class_='kq_ngay').text.strip()
            message = format_result(table, date_header)
            await update.message.reply_text(message)
        else:
            await update.message.reply_text(
                f"‚ùå Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ cho ng√†y {day:02d}/{month:02d}/{current_year}.\n"
                "Vui l√≤ng th·ª≠ l·∫°i v·ªõi ng√†y kh√°c."
            )
            
    except Exception as e:
        logging.error(f"Error fetching XSMB result for date: {e}")
        await update.message.reply_text(
            "‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y k·∫øt qu·∫£.\n"
            "Vui l√≤ng th·ª≠ l·∫°i sau."
        )

async def check_xien2(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        command = update.message.text.strip().lower()
        
        # L·∫•y ph·∫ßn s·ªë sau /xien2_
        numbers_part = command[7:]
        num1, num2 = map(str, numbers_part.split('_'))
        
        # Chuy·ªÉn s·ªë v·ªÅ format 2 ch·ªØ s·ªë
        num1 = num1.zfill(2)  # Th√™m s·ªë 0 ph√≠a tr∆∞·ªõc n·∫øu c·∫ßn
        num2 = num2.zfill(2)  # Th√™m s·ªë 0 ph√≠a tr∆∞·ªõc n·∫øu c·∫ßn
        
        # Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa s·ªë
        if not (num1.isdigit() and num2.isdigit()):
            raise ValueError
            
        # L·∫•y k·∫øt qu·∫£ x·ªï s·ªë ng√†y hi·ªán t·∫°i
        current_datetime = datetime.now()
        cutoff_time = time(18, 30)

        # Ki·ªÉm tra th·ªùi gian ƒë·ªÉ l·∫•y k·∫øt qu·∫£ ph√π h·ª£p
        if current_datetime.time() >= cutoff_time:
            target_date = current_datetime.date()
        else:
            target_date = current_datetime.date() - timedelta(days=1)

        # L·∫•y k·∫øt qu·∫£ x·ªï s·ªë
        url = "https://rongbachkim.net/ketqua.html"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        }
        
        response = requests.get(url, headers=headers, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # T√¨m b·∫£ng k·∫øt qu·∫£
        table = soup.find('table', class_='ketqua')
        
        if table:
            # L·∫•y t·∫•t c·∫£ c√°c s·ªë trong b·∫£ng k·∫øt qu·∫£
            all_numbers = []
            for td in table.find_all('td', class_=lambda x: x and x.startswith('kq_')):
                number = td.text.strip()
                if number:
                    # L·∫•y 2 s·ªë cu·ªëi c·ªßa m·ªói gi·∫£i
                    all_numbers.append(number[-2:] if len(number) >= 2 else number)

            # Ki·ªÉm tra xem c·∫£ 2 s·ªë c√≥ xu·∫•t hi·ªán trong k·∫øt qu·∫£ kh√¥ng
            found_numbers = []
            if num1 in all_numbers:
                found_numbers.append(num1)
            if num2 in all_numbers:
                found_numbers.append(num2)

            # T·∫°o th√¥ng b√°o k·∫øt qu·∫£
            date_str = target_date.strftime("%d/%m/%Y")
            if len(found_numbers) == 2:
                await update.message.reply_text(
                    f"üéâ CH√öC M·ª™NG!\n"
                    f"C·∫£ hai s·ªë {num1} v√† {num2} ƒë·ªÅu xu·∫•t hi·ªán trong k·∫øt qu·∫£ ng√†y {date_str}!"
                )
            elif len(found_numbers) == 1:
                await update.message.reply_text(
                    f"üòä S·ªë {found_numbers[0]} c√≥ xu·∫•t hi·ªán trong k·∫øt qu·∫£ ng√†y {date_str}\n"
                    f"Nh∆∞ng s·ªë {num2 if found_numbers[0] == num1 else num1} kh√¥ng xu·∫•t hi·ªán."
                )
            else:
                await update.message.reply_text(
                    f"üòî R·∫•t ti·∫øc!\n"
                    f"C·∫£ hai s·ªë {num1} v√† {num2} ƒë·ªÅu kh√¥ng xu·∫•t hi·ªán trong k·∫øt qu·∫£ ng√†y {date_str}."
                )
        else:
            await update.message.reply_text("‚ùå Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c k·∫øt qu·∫£ x·ªï s·ªë. Vui l√≤ng th·ª≠ l·∫°i sau.")
            
    except Exception as e:
        logging.error(f"Error checking xien2: {e}")
        await update.message.reply_text("‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.")

def format_result(table, date_header):
    """Format XSMB result table."""
    message = "K·∫æT QU·∫¢ X·ªî S·ªê MI·ªÄN B·∫ÆC\n"
    message += f"{date_header}\n"
    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    # Gi·∫£i ƒêB
    db = table.find('td', class_='kq_0').text.strip()
    message += f"Gi·∫£i ƒêB:   {db}\n"
    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    # Gi·∫£i nh·∫•t
    nhat = table.find('td', class_='kq_1').text.strip()
    message += f"Gi·∫£i nh·∫•t: {nhat}\n"
    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    # Gi·∫£i nh√¨
    nhi_cells = table.find_all('td', class_=['kq_2', 'kq_3'])
    nhi = '    '.join([cell.text.strip() for cell in nhi_cells])
    message += f"Gi·∫£i nh√¨:  {nhi}\n"
    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    # Gi·∫£i ba
    ba_cells = table.find_all('td', class_=['kq_4', 'kq_5', 'kq_6', 'kq_7', 'kq_8', 'kq_9'])
    ba_1 = '    '.join([ba_cells[i].text.strip() for i in range(3)])
    ba_2 = '    '.join([ba_cells[i].text.strip() for i in range(3, 6)])
    message += f"Gi·∫£i ba:   {ba_1}\n"
    message += f"          {ba_2}\n"
    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    # Gi·∫£i t∆∞
    tu_cells = table.find_all('td', class_=['kq_10', 'kq_11', 'kq_12', 'kq_13'])
    tu = '     '.join([cell.text.strip() for cell in tu_cells])
    message += f"Gi·∫£i t∆∞:   {tu}\n"
    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    # Gi·∫£i nƒÉm
    nam_cells = table.find_all('td', class_=['kq_14', 'kq_15', 'kq_16', 'kq_17', 'kq_18', 'kq_19'])
    nam_1 = '     '.join([nam_cells[i].text.strip() for i in range(3)])
    nam_2 = '     '.join([nam_cells[i].text.strip() for i in range(3, 6)])
    message += f"Gi·∫£i nƒÉm:  {nam_1}\n"
    message += f"          {nam_2}\n"
    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    # Gi·∫£i s√°u
    sau_cells = table.find_all('td', class_=['kq_20', 'kq_21', 'kq_22'])
    sau = '      '.join([cell.text.strip() for cell in sau_cells])
    message += f"Gi·∫£i s√°u:  {sau}\n"
    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    # Gi·∫£i b·∫£y
    bay_cells = table.find_all('td', class_=['kq_23', 'kq_24', 'kq_25', 'kq_26'])
    bay = '       '.join([cell.text.strip() for cell in bay_cells])
    message += f"Gi·∫£i b·∫£y:  {bay}"
    
    return message

async def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle unknown commands and messages."""
    await help_command(update, context)

def main():
    """Start the bot."""
    application = Application.builder().token(TOKEN).build()

    # Th√™m handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("ketqua", get_full_result))
    application.add_handler(MessageHandler(filters.Regex(r'^/ketqua_\d{1,2}_\d{1,2}$'), get_result_by_date))
    # S·ª≠a l·∫°i pattern cho xien2 ƒë·ªÉ b·∫Øt ƒë√∫ng format
    application.add_handler(MessageHandler(filters.Regex(r'^/xien2_\d{1,2}_\d{1,2}$'), check_xien2))
    
    # Handler cho c√°c message kh√¥ng h·ª£p l·ªá
    application.add_handler(MessageHandler(filters.TEXT, unknown))

    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main() 